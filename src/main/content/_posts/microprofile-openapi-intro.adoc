---
layout: post
title:  "MicroProfile OpenAPI 1.0"
date:   2018-05-22 12:05:00 +0100
categories: blog
blog_description: "Learn how to generate OpenAPI v3 documents from your RESTful application using the new MicroProfile OpenAPI programming model in Liberty."
author_picture: https://avatars1.githubusercontent.com/u/5042215
---
:description: Learn how to generate OpenAPI v3 documents from your RESTful application using the new MicroProfile OpenAPI programming model in Liberty..
=  Introducing MicroProfile OpenAPI 1.0
Arthur De Magalhaes <https://github.com/arthurdm>

Starting with Open Liberty 18.0.0.1 you can access the `mpOpenAPI-1.0` feature.  This is the implementation of the http://microprofile.io/project/eclipse/microprofile-open-api[MicroProfile OpenAPI 1.0] spec released in December 2017.


## State of the API Economy

If you have written REST APIs in the last few years, chances are you were asked to provide the Swagger file that described your APIs.  Conversely if you wanted to use a REST API from another provider you would have been given their Swagger file.  

The Swagger specification certainly rose above other similar standards, such as API Blueprint and RAML, but it was still being governed by a single entity.  That was until 2016, when the main players in the API industry got together and formed the https://www.openapis.org/membership/members[OpenAPI Initiative].  The Swagger v2 specification was donated to the OpenAPI Initiative and renamed to OpenAPI v2, and in July 26, 2017 a new, more powerful specification was released:  https://www.openapis.org/blog/2017/07/26/the-oai-announces-the-openapi-specification-3-0-0[OpenAPI v3]

The consortium governance model of this new specification meant that new tools vendors started to emerge with libraries and SDKs.  Java developers had a choice from many different annotations or libraries to include in their application – but none that was officially supported by any of the major Java application server vendors, which affected portability and consistency.  There was an increasing need for an official Java programming model that was supported by different vendors and integrated with other modern libraries.  

## Enter MicroProfile OpenAPI

Similarly to how the Swagger specification was used as the base for a community-driven specification, the Java libraries for Swagger were used as the base for the http://microprofile.io/)[MicroProfile community] programming model for OpenAPI v3: https://github.com/eclipse/microprofile-open-api[MicroProfile OpenAPI].  This specification outlined an official set of annotations and interfaces that allow developers to successfully generate OpenAPI v3 documentation for their Java RESTful APIs.

The following diagram provides an overview of the MicroProfile OpenAPI architecture, which has been supported in Open Liberty starting with version 18.0.0.1:

image::img/ol_mp_openapi.png[MP OpenAPI Architecture]

There are many different ways to provide input for the generation of the resulting OpenAPI document.
The MicroProfile OpenAPI specification requires vendors to produce a valid OpenAPI document from pure JAX-RS 2.0 applications. This means that Open Liberty processes all the relevant JAX-RS annotations (such as @Path and @Consumes) as well as Java objects (POJOs) used as input or output to JAX-RS operations. This is a good place to start for application developers that are new to OpenAPI: just deploy your existing JAX-RS application into Open Liberty and check out the output from /openapi!

The application developer then has a few choices:
1.	Augment those JAX-RS annotations with the OpenAPI https://github.com/eclipse/microprofile-open-api/blob/master/spec/src/main/asciidoc/microprofile-openapi-spec.adoc#annotations[Annotations]. Using annotations means developers don’t have to re-write the portions of the OpenAPI document that are already covered by the JAX-RS framework (e.g. the HTTP method of an operation).  This is the most common path, so definitely check out some of the https://github.com/eclipse/microprofile-open-api/blob/master/spec/src/main/asciidoc/microprofile-openapi-spec.adoc#412-detailed-usage-of-key-annotations[examples] to get familiar with some of these annotations and its generated output.

2.	Take the initial output from /openapi as a starting point to document your APIs via https://github.com/eclipse/microprofile-open-api/blob/master/spec/src/main/asciidoc/microprofile-openapi-spec.adoc#static-openapi-files[Static OpenAPI files]. It’s worth mentioning that these static files can also be written before any code, which is an approach often adopted by enterprises that want to lock-in the contract of the API. In this case, we refer to the OpenAPI document as the "source of truth", by which the client and provider must abide.

3.	Use the https://github.com/eclipse/microprofile-open-api/blob/master/spec/src/main/asciidoc/microprofile-openapi-spec.adoc#programming-model[API interfaces] to provide a bootstrap (or complete) OpenAPI model tree. 

Additionally, a https://github.com/eclipse/microprofile-open-api/blob/master/spec/src/main/asciidoc/microprofile-openapi-spec.adoc#filter[Filter] is described which can update the OpenAPI model after it has been built from the previously described documentation mechanisms.

You are now ready to try out an application that has MicroProfile OpenAPI enabled!  Just head over to our  https://github.com/microservices-api/oas3-microprofile-app[sample app] and follow the instructions to build an Open Liberty docker container that with MicroProfile OpenAPI!  

## Additional Information

For more information on the MicroProfile OpenAPI specification, see the http://download.eclipse.org/microprofile/microprofile-open-api-1.0.1/microprofile-openapi-spec.html[official MicroProfile OpenAPI 1.0 release].

Get involved in the MicroProfile community at: http://microprofile.io
